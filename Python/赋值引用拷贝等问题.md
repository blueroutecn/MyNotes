# Python深浅拷贝

------

## 一个问题

昨天写代码遇到一个很奇怪问题，简化后表示如下：

```python
li = [1, 2, 3, 4]
li2 = li
li2[1] = 'a'
print li2
print li

# 得到的输入出:
li2:[1, 'a', 3, 4]
li1：[1, 'a', 3, 4]
```

从输出可以看到,li1的值也改了，感觉 `li2 = li`向是令li2的指针指向了li，导致li的值也改变了。尝试输出了一下li和li2的地址

```
print li2
print li

139757257136896
139757257136896
```

可以看到，li和li2的地址也是相同的。略去一番纠结，最终查出了**python赋值、引用、拷贝**的问题；

## 浅拷贝

#### 问题解决

不再过多叙述原理，直接写出以上问题的解决：

```python
li = [1, 2, 3, 4]
li2 = li[:] # li[:]是对value的复制
li2[1] = 'a'
print li2
print li

'''
    输出:
    [1, 'a', 3, 4]
    [1, 2, 3, 4]
'''

print id(li2)
print id(li)

'''
    输出:
    140343252711040
    140343252712192
'''

```

由上可以看到，通过`li2 = li[:]`实现了改变li2但不改变li,这叫做**浅拷贝**

#### 涉及的原理

* python没有**变量**,我们平时所说的变量其实只是**标签**,是**引用**；可以说，python**没有赋值，只有引用**

* li[:]生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制。

#### 关于浅拷贝的另一个例子

```python
>>> values = [0, 1, 2]
>>> values[1] = values
>>> values

'''

Out:[0, [...], 2]
# 从这里可以看到，结果被赋值了无数次(本来预想结果为[0, [0, 1, 2], 2])

'''
```

由于上述提到的python“引用”的本质，要想得到 [0, [0, 1, 2], 2] 这个对象，你不能直接将 values[1] 指向 values 引用的对象本身，而是需要吧 [0, 1, 2] 这个对象「复制」一遍，得到一个新对象，再将 values[1] 指向这个复制后的对象(Python 里面复制对象的操作因对象类型而异，复制列表 values 的操作是 value1 = values[:])。因此正确的实现方法是

```python
values[1] = values[:]
```



## 深拷贝

#### 浅拷贝的问题

* 一个例子

```python

a = [0, [1, 2], 3]
b = a[:]
a[0] = 8
a[1][1] = 9 # 对嵌套对象的赋值

print a
print b
'''
a：[8, [1, 9], 3]
b：[0, [1, 9], 3]
'''

```

#### 深拷贝

* 正确的**复制嵌套元素**的方法是进行**深复制(deep copy)**

关于此的图示可参考此文[https://my.oschina.net/leejun2005/blog/145911](https://my.oschina.net/leejun2005/blog/145911)

```python
import copy

a = [0, [1, 2], 3]
b = copy.deepcopy(a)
a[0] = 8
a[1][1] = 9
print a
print b

'''
a：[8, [1, 9], 3]
b：[0, [1, 2], 3]
'''

```

## 引用 VS 拷贝

#### 一些知识点

* 没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能**浅层复制**。

* 字典 copy 方法，D.copy() 能够**复制字典**，但此法只能**浅层复制**

* 有些内置函数，例如 list，能够生成拷贝 list(L)

* copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy

* 对于不可变对象和可变对象来说，浅复制都是复制的引用，只是因为复制不变对象和复制不变对象的引用是等效的（因为对象不可变，当改变时会新建对象重新赋值）。所以看起来浅复制只复制不可变对象（整数，实数，字符串等），对于可变对象，浅复制其实是创建了一个对于该对象的引用，也就是说只是给同一个对象贴上了另一个标签而已

#### 示例代码

```python

L = [1, 2, 3]
D = {'a':1, 'b':2}
A = L[:]
B = D.copy()
print "L, D"
print  L, D
print "A, B"
print A, B
print "--------------------"
A[1] = 'NI'
B['b'] = 'test'
B['c'] = 'spam'
print "L, D"
print  L, D
print "A, B"
print A, B


'''
L, D
[1, 2, 3] {'a': 1, 'b': 2}
A, B
[1, 2, 3] {'a': 1, 'b': 2}
--------------------
L, D
[1, 2, 3] {'a': 1, 'b': 2}
A, B
[1, 'NI', 3] {'a': 1, 'c': 'spam', 'b': 'test'}

'''

```

## 增强赋值与共享引用

#### x = x + y 与 x += y

* x = x + y，x 出现两次，必须执行两次，**性能不好**，合并必须新建对象 x，然后复制两个列表合并,**属于复制/拷贝**

* x += y，x 只出现一次，也只会计算一次，**性能好，不生成新对象**，只在内存块末尾增加元素。

* 当 x、y 为list时， += 会自动调用 extend 方法进行合并运算，in-place change,**属于共享引用**

```python
L = [1, 2]
M = L
L = L + [3, 4]
print L, M
print "-------------------"
L = [1, 2]
M = L
L += [3, 4]
print L, M


[1, 2, 3, 4] [1, 2]
-------------------
[1, 2, 3, 4] [1, 2, 3, 4]

```


关于赋值、拷贝的内容先整理这些，还涉及到关于**可变对象**、**不可变对象**的内容，另外整理一篇。另外，[python赋值、引用、拷贝、作用域问题](https://my.oschina.net/leejun2005/blog/145911)中有详细配图，以及关于**不可变/可变**对象内容，较为全面


## 参考文章

* [python赋值、引用、拷贝、作用域问题](https://my.oschina.net/leejun2005/blog/145911)（这篇太好啦！！！）

* [Python中的变量、引用、拷贝和作用域](http://xianglong.me/article/python-variable-quote-copy-and-scope/)

* [https://www.zhihu.com/question/21000872](https://www.zhihu.com/question/21000872)
