# 第四章 软件的缺陷与漏洞

------

## 软件缺陷与漏洞机理概述

#### 什么是安全漏洞？

* 安全漏洞的本源：**代码流程**的变化
    * 任何安全漏洞都是导致程序**走到别的流程上去**了，而非设计流程

* 安全漏洞是软件**bug的一个子集**

*  安全漏洞
    * 软件或硬件设计生产过程中出现的**bug**，该bug在**一定条件下可以被触发，引起信息安全相关的问题**。

    * 程序中存在**危害本地安全策略的问题或弱点**，大多数是指那些会导致程序**强制执行一些不同于作者本来意图的行为**。
    
#### 安全漏洞在何处潜伏？

* 系统设计

* 代码实现

#### 安全漏洞对系统的威胁

* 网络攻击为什么容易？
    * 静态性

    * 确定性

    * 相似性

* 非法获取访问权限

    * 访问控制：**防止未经授权使用资源**，包括防止以非授权方式使用资源。

    * 访问权限：**访问控制的访问规则**，用来区别不同访问者对资源的访问权限。

* 权限提升
    * 攻击者通过攻击某些有缺陷的系统程序，把**当前较低的账户权限提升到更高级别的用户权限**
    
    * 由于管理员权限较大，通常将**获得管理员权限看做是一种特殊的权限提升**

* 拒绝服务

    * 拒绝服务攻击的目的是**使计算机软件或系统无法正常工作、无法提供正常的服务**。

    * 根据存在漏洞的应用程序的应用场景，可划分为**本地拒绝服务漏洞**和**远程拒绝服务漏洞**

    * 与网络层面的Dos相比，侧重于软件或系统组件**漏洞引发的拒绝服务攻击**

* 恶意软件植入

* 当恶意软件明确攻击目标后，需要通过**特定方式将攻击代码植入到目标中**

    * 主动植入：由程序自身利用系统的**正常功能或缺陷漏洞**将攻击代码植入到目标中，而**不需要人的任何干预**。

    * 被动植入：恶意软件将攻击代码植入到目标主机时需要**借助用户的操作**（通常和社会工程学的攻击方法相结合，诱使用户触发漏洞）
    
* 数据丢失或泄露

* 第一类漏洞是由于对**文件**的**访问权限设置错误而导致文件被非法读取**

* 第二类漏洞常见于**Web应用程序**，由于没有充分验证**用户的输入**，导致文件被非法读取

* 第三类漏洞主要是**系统漏洞**，导致**服务器信息泄露** 。

#### 安全漏洞的分类

* 内存破坏导致代码执行
    * 栈缓冲区溢出

    * 堆缓冲区溢出

    * 格式串问题

    * 其他类型的问题
    
* 从用户群体分类

    * **大众类**软件漏洞：Windows、QQ、IE等

    * **专用软件类**漏洞：AIX、DB2、Oracle等
    
* 从**作用范围**角度

    * **远程漏洞**

    * **本地漏洞**
    
* 从**触发条件**分类

    * 可**主动发起攻**击的漏洞

    * 只能**被动等待**的漏洞
    
* 从**数据角度**分类

    * 能读**按理不能读**的数据
        * 内存中的数据、文件中的数据...

    * 能把指定的内容写入指定的地方

    * 输入的数据可以被执行
        * 被当作SQL执行、SHELL执行、程序代码执行
        
* 从**时序**上分类

    * 已发现**很久**的漏洞

    * **刚发现**的漏洞

    * **0 day**

#### 典型的安全漏洞

* ** SQL注入

* ** 跨站漏洞

* ** 命令执行漏洞

* ** 缓冲区溢出

#### 漏洞利用

* 漏洞利用是黑客针对已有的漏洞，根据漏洞的类型和特点而**采取相应的技术方案，进行尝试性或实质性的攻击**

* 通过触发漏洞来隐蔽地**执行恶意代码**
    * 触发漏洞来完成恶意操作的程序通常被称为**exploit**

* 如果一个BUG不能被利用来做**“原本认为”不能做的事（安
全相关的）**，那么就不能被称之为安全漏洞

* 不同角度看漏洞

* **数据操作**视角
    
    * 操作原本不能操作的数据、读访问——泄密、写访问

* **权限视角**

    * 主要为**权限绕过、权限提升**
    
* **代码执行**角度

    * 程序将**输入的内容作为代码来执行**

    * 绕过认证、权限提升
    
#### 漏洞产生的原因

* 技术因素

* 非技术因素

        
#### 总结

![](http://ouzh4pejg.bkt.clouddn.com/vulnerability_conclusion.png)

## 典型软件漏洞机理分析

* 缓冲区溢出

    * 根据操作系统的不同，一个进程可能被**分配到不同的内存区域**去执行。但根据进程使用的内存区域的预定功能划分，一般可大致分
为以下三个部分：

        * 代码区

            * 存储被装入执行的**二进制机器代码**

            * 处理器从内存的该区域一条一条地取出指令和操作数，并送入算数逻辑单元进行运算。

            * 通常情况下**只允许读，不允许修改**
    
        * 静态数据区
        
            * 用于**存储全局变量**
    
            * 进一步可以划分为**初始化的数据区（datasegment）**和**未初始化的数据区（bsssegment）**
    
            * 初始化的数据区用于存放已经初始化的**全局变量和静态变量**
        
            * 未初始化的数据区用于保存**未初始化的全局变量**
    
        * 动态数据区
            * 用于存放程序运行时的**动态变量，包括两个区域**
    
            * 栈区（stack segment）：用于存储函数之间的**调用关系以及函数内部的变量**，以保证**被调用函数在返回时回到父函数中继续执行**。
    
            * 堆区（heap segment）：程序运行时向系统**动态申请的内存空间**位于堆区，用
    完之后需要程序**主动释放所请求的内存空间**
    
            ![](http://ouzh4pejg.bkt.clouddn.com/memory_distribute.png)
    
    * 几个术语
    
        * 缓冲区（buffer）: 内存空间中用于存储程序运行时**临时数据**的一片**大小有限且连续的内存区域**
    
    
        * 溢出（overflow）:数据过长导致无法存储在预期区域内，**覆盖了存储其他数据的区域**
    
        * 缓冲区溢出定义:当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据**覆盖到了合法数据上**。
        
        * 安全函数: 可以**限制所操作的数据长度**， 正确使用则不会导致缓冲区问题的函数(eg.strncpy(DstBufferm,SrcBuffer,sizeof(DstBuffer)-1);),与之相对的**非安全函数**（eg. strcat(),strcpy(),sprintf()...）则需要额外的**边界检查**。
        
        * 边界检查（Boundary Check）:在向缓冲区中存储数据时，确定**数据长度是否会超
出缓冲区边界**
        ```C
        if(strlen(SrcBuffer)<sizeof(DstBuffer))
            strcpy(DstBuffer,SrcBuffer);
        else
            printf(“DstBuffer is too small.\n”);
        ```
        * 栈不可执行
            某些型号的CPU支持对内存是否可执行的标志位，操作系统可以利用该特性在进程初始化时将堆栈设置为不可执行
        
    * 缓冲区溢出的分类
        * 栈缓冲区溢出(stack overflow): 溢出发生在**栈区**中, 覆盖堆栈结构
        * 堆缓冲区溢出(heap overflow): 溢出发生在**堆区**中,覆盖指定的四字节指针

    * 类似缓冲区溢出的问题
        * 格式串问题
        * 覆盖指定的若干指针
        
    * 缓冲区溢出漏洞存在的原因
        * 没有使用**安全函数**，也没有进行**边界检查**
        * 没有**正确地使用安全函数**
        
            ```C
            strcpy(DstBufferm,SrcBuffer,sizeof(SrcBuffer)-1)
            ```
            
        * 设计和计算失误
        
    * 导致缓冲区溢出的几种方式
        * 错误的双字节字符串长度比较

        * 用源字符串长度做拷贝限制

        * strncpy等字符串截断拷贝函数的陷阱

        * 如果源字符串长度大于限定长度参数，strncpy会**按照限定长度拷贝到目标，但并不会在最后加上字符串结束符’\0’**(这个陷阱可能导致不易察觉的缓冲区溢出)

        * **整形变量**处理不当（整形溢出）
        
    * 栈溢出
        * 系统栈和函数调用
        
        * 如果数据溢出到了函数的返回地址，则改写了函数返回地址；**如返回地址被改写，函数返回时，流程会转入到被改写的地址**。
    
    * 堆溢出
        * 堆的特性
        ![](http://ouzh4pejg.bkt.clouddn.com/heap_distrite.png)
            * 在程序运行时**动态分配内存**。
            
            * 使用时需要程序员**使用专有的函数进行申请**
            
            * 一般用一个**堆指针**来使用申请得到的内存
            
            * 使用完毕后需要**将堆指针传给推释放函数回收这片内存**，否则会造成内存泄漏
            
            * 堆与栈的区别
            ![](http://ouzh4pejg.bkt.clouddn.com/heap_stack_diff.png)
            
            * 堆块
                * 空闲态 ：堆块被链入**空链表**中，由系统管理 。

                * 占有态 ：堆块会返回一个由程序员定义的句柄，由程序员管理 
                
                * 空闲堆块： 比占有堆块多出了**两个4字节的指针**，这两个指针用于**链接系统中的其他空闲堆块**
                * 堆溢出利用：用精心构造的数据去溢出覆盖**下一个堆块的
块首**，使其 改写 块首中的 flink指针和blink指针，然后在分配、释放、合并等操作发生时伺机获得一次**向内存任意地址写入任意数据的 机会 （ Arbitrary Dword Reset, 又称
Dword Shoot ）**。通过这个机会，可以 控制 设计的目标（任意地址）， 选择 适当的目标数据，从而 劫持进程，运行 shellcode 

                ![](http://ouzh4pejg.bkt.clouddn.com/heap_overflow.png)

* 整型溢出

* 单字节溢出

* 格式化串漏洞

**以上三部分内容暂不整理，具体见课件**

* 覆盖C++虚函数指针

![](http://ouzh4pejg.bkt.clouddn.com/virtual_func.png)


* vptr是指向**虚函数表**的指针，虚函数表内有具体每个**虚函数的地址**。

* 虚函数覆盖的本质是:

* Web应用程序漏洞

    * 注入
    
        * 防范：
            * 参数化查询
            * 过滤与转换
            * 服务器与数据库安全设置
    
    * 跨站脚本
    
        * 反射型XSS
        
        * 存储型XSS
       
        * DOM Based XSS
            * 通过**修改页面DOM节点数据信息**而形成的XSS跨站脚本攻击
            
        * 防范：
            * HTTPonly
            
            * 输入输出检查
    
    * 失效的身份认证和
    
    * 会话管理
    
    * 不安全的直接对象引用
    
    * 安全配置错误
    
    * 敏感信息泄露
    
    * 功能级访问控制缺失
    
    * 跨站请求伪造
    
    * 使用含有已知漏洞的组件
    
    * 未验证的重定向和转发

## Windows系统安全机制及漏洞防护技术

* Safe C library
    * Safe C library： 一组**更安全的字符串处理函数**（#include <strsafe.h>）
    
* Standard Annotation Languages(SAL)

    * SAL:为编码添加注释，帮助工具发现那些不易被发觉的bug

    * 使用SAL: 你要做的只是#include<sal.h>，和一些关键字

* 栈溢出检查——StatckCookie（GS选项）

    ![](http://ouzh4pejg.bkt.clouddn.com/stack_cookie.png)
    
    * StackCookie:在**返回地址之前**压入一个随机生成的StackCookie.函数返回前，先**检查StackCookie是否被修改**。
    
    * 使用StackCookie: VS中 /GS选项，这是**默认**的

* 数据执行保护——DEP

    * 缓冲区溢出最常见的利用方式是：在栈中精心构造二进制串溢出原有数据结构进而改写**函数返回地址**，使其跳转到位于栈中的shellcode执行。**如果是栈上数据不可执行**，那么就可以阻止这种漏洞利用方式的成功实施。
    
    * DEP（data execution prevention）：微软随Windows XP SP2和Windows2003 SPI的发布而引入的一种**数据执行保护机制** (是否可执行的标识？？)。
    
    * 对抗DEP
        * ret2libc绕过DEP: **无Shellcode**的漏洞利用技术，即**不直接跳转到shellcode，而是去执行库中的代码**，被执行的代码也就可以看做是恶意代码
        
        * 将shellcode写入**不受DEP保护的可执行内存中**
        
        * 关闭进程DEP
        
* 地址空间分布随机化——ALSR（Windows Vista开始引入）

    * 原理
        * 通过对堆、栈、共享库映射等**线性区域布局的随机化，增加攻击者预测目的地址的难度**，防止攻击者直接定位攻击代码位置，达到阻止漏洞利用的目的。
        
    * 实现
        * 编译器选项——DYNAMICBASE

        * 映像加载基址随机化
* SafeSEH
    
    * 结构化异常处理（Structured Exception Handling，SEH）

    * SafeSEH是用来保护和检测堆栈中的**SEH函数指针**被覆盖的技术
    
    * 原理：在编译器在链接生成二进制IMAGE时，把所有**合法的异常处理函数的地址解析出来制成一张安全的SEH表**，保存在程序的IMAGE的数据块里。当程序调用异常处理函数时会将**函数地址与安全SHE表中的地址进行匹配**。检查调用的异常处理函数是否位于表中如果IMAGE不支持safeSEH，则表的地址为0.
    
    * SafeSEH的安全性
        * 利用未开启SafeSEH的模块作为跳板绕过

        * 当进程中存在一个不支持SafeSEH的image时，**整个SafeSEH的机制就很有可能失效**。
        
        * 支持SafeSEH需要**.net编译器支持**，仍有大量的第三方程序和库未使用.net编译或未采用SafeSEH选项。

* EMET
    * EMET（enhanced mitigation experience toolkit）是微软推出的一套用来**缓解漏洞攻击、提高应用软件安全性**的增强型体验工具


## 软件漏洞的利用和发现

#### 漏洞利用和Exploit

* 漏洞从发现到产生实际危害的过程
    * 漏洞挖掘 → 漏洞分析 → 漏洞利用

    * 漏洞利用是黑客针对已有的漏洞，根据漏洞的类型和特点而**采取相应的技术方案，进行尝试性或实质性的攻击**
    
* Exploit：**触发漏洞并完成恶意操作的程序**通常被称为Exploit。

    * 通常情况下，Exploit是以一个**独立程序的形式**出现。该程序可以根据目标环境构造一段用于**实现攻击的二进制串（也称为Payload）**
    
* shellcode
    ![](http://ouzh4pejg.bkt.clouddn.com/exploit.png)

    * 起初，shellcode是指植入进程中**获得shell**的代码；后来通称缓冲区溢出攻击中**植入进程的代码**
    
    * 通常是一段**机器码**（C语言、汇编语言）， 植入目标进程后CPU可以**直接运行**

    * 具备代码**重定位和API自搜功能**，不严重依赖于系统或进程

    * 为了增加代码的通用性和减少对缓冲区大小的依赖，必要时需要**对shellcode编码和压缩**
    
    * shellcode的典型功能
        * 正向连接: 在目标主机运行后再打开一个监听端口，等待攻击者主动连接

        * 反向连接: 为了绕过防火墙，shellcode采取**目标主机反向连接攻击主机的方式**

        * 下载程序并执行，或运行后会自动到指定的URL去**下载一个执行的文件并运行**
    
        * 网页挂马类漏洞的漏洞利用
    
        * 生成**可执行文件**并运行,或攻击者直接将**可执行文件嵌入到shellcode中。Shellcode的目的就是将其释放出来并运行**
    
        * 文档捆绑类漏洞的漏洞利用

* 漏洞利用的具体技术
    * 修改内存变量
        * 修改能够影响程序执行的重要标志变量，往往可以**改变程序的流程**

    * 修改代码逻辑
    
    * 修改函数返回地址
    
    * 修改函数指针
    
    * 攻击异常处理机制
    
    * 修改PEB中线程同步函数的入口地址

#### 软件漏洞利用平台及框架

* Core Impact

* Immunity Canvas

* Metasploit Framework

#### 软件漏洞挖掘技术及工具

**漏洞是BUG的子集，测试的所有方法都适用于漏洞挖掘**

* 基于源代码的静态分析

    * 基于**源代码**，可直接从程序逻辑的角度寻找漏洞。**不执行目标系统对程序源代码进行分析**

* 符号执行
    
    * 在**不执行程序**的前提下，用符号值表示程序变量的值，然后**模拟程序执行**来进行相关分析的技术

* 动态分析
    * 通过目标系统的**一次或多次运行**进行分析。
        * 植入技术
        * 部分求值
        * 动态切片

* Fuzzing技术
    * Fuzzing测试一种特殊的黑盒测试法，**不关注软件的功能业务和逻辑流程，重点关注于软件的健壮性**

* 逆向分析



* 基于补丁对比的逆向分析

    * 根据补丁前后**应用程序或其中模块的机制变化**，可发现并定位漏洞

    * 对补丁前后的程序进行**反编译**，通过**对比差异**，定位漏洞

        * 发生漏洞的代码段**周围通常还会有其他漏洞**
       
        * 在发布补丁时引入了额外的功能代码，这部分代码与原有代码**耦合性较低，这也会增大了再次漏洞的概率**
        
* 漏洞挖掘
    
    * 对敏感区域：一步步逐行看源码或反汇编码！

## 构建安全的软件

* 软件安全开发过程

* 重要的安全法则

* 安全的编码技术

* 适当的访问控制
